\documentclass[12pt, oneside]{article}
\usepackage{amsmath, amsthm, amssymb, calrsfs, wasysym, verbatim,  color, graphics, geometry}

\geometry{tmargin=.75in, bmargin=.75in, lmargin=.75in, rmargin = .75in}

\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Cdot}{\boldsymbol{\cdot}}

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{conv}{Convention}
\newtheorem{rem}{Remark}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}


\title{Resume: }
\author{Matias Mazzanti}
\date{}

\begin{document}

\maketitle
\tableofcontents

\vspace{.25in}

\section{ToDo}
\begin{itemize}
  \item Probabilidades (marginal, condicional, etc)
  \item CrossValidation vs Test
  \item Combinations and permutation
  \item Poisson distribution
  \item Random Walk
  \item Divergencia de KL
  \item Probabilistic generative model (generative?)
  \item Likelihood
  \item Metric (evidence)
  \item Multivariant Gaussian
  \item TrueSkill draw
\end{itemize}


\section{Algoritmo 3}
Algoritmo eficiente = orden polinomial
Algoritmo no eficiente = exponencial

Tecnicas de diseño de algoritmos
\begin{itemize}
  \item Fuerza bruta
  \item Backtracking
  \item Algoritmos golosos
  \item Recursividad
  \item Dividir y conquistar
  \item Programacion dinamica
  \item Heuristicas y algoritmos aproximados
\end{itemize}

\subsection{Clase1}
Ej: allar todas las formas posibles de colocar n reinas en un tablero de ajedrez de n x n casillas,
de forma que ninguna reina amenace a la otra.
\paragraph{Fuerza bruta}:
Analizar todas las posibilidades y quedarme con las que me interesan.

Solucion, genero TODAS las posibilidades y veo cuales cumplen.
Tengo n*n casillas y tengo que poner n reinas.
Tengo el combinatorio de (n$^2$ n) de posibilidades.

\paragraph{Backtracking}:
Tecnica para recorrer sistematicamente todas las posibles configuraciones del espacio de soluciones.
Las posibles configuraciones las llamamos soluciones validas.
Se parece a fuerza bruta pero aprovecha propiedades del problema para evitar analizar todas
las configuraciones posibles.
Se suele armar un vector de las soluciones candidatas.
Se puede pensar este espacio de busqueda como un arbol dirigido donde cada
vertice representa una solucion parcial.
Un vertice x es hijo de y si la solucion parcial de x se puede extender desde la
solucion parcial y.
La raiz del arbol se corresponde con el vector vacio.
Los vertices del primer nivel del arbol seran las soluciones parciales que ya tienen definidas
el primer elemento.
Los de segundo nivel las que tienen los dos primeros y asi siguierndo.
Si el vertice x corresponde a la solucion parcial a = $(a_1, a_2,...,a_k)$ por
cada valor posible que puede tomar $a_{k+1}$ se ramifica el arbol, generando
tantos hijos de x como posibilidades haya para $a_{k+1}$.
Las soluciones completas (cuando todos los$a_i$ tienen valor) corresponden a las
hojas del arbol.
Cuando podemos deducir que una solucion parcial no nos llevara a una solucion valida, no
es necesario seguir explorando esa rama del arbol de busqueda (se poda el arbol) y se
retrocede hasta encontrar un vertice con un hijo valido por donde seguir la exploracion.

Puedo podar tanto por factibilidad, que es cuando ninguna extension de la solucion parcial
derivara en una solucion valida del problema.
O bien por optimalidad, en que ninguna extension de la solucion parcial derivara en una solucion
del prblema optima.
En este ultimo caso puedo cortar la busqueda una vez que se que la solucion aparente que
puedo encontrar por una rama va a ser peor (en el sentido del problema) a alguna que ya encontre.
Para poder aplicar la poda por factibilidad, la representacion de las soluciones debe cumplir que
si una solucion parcial $a$ no cumple las propiedades deseadas, tampoco lo hara cualquier
extension posible de ella (propiedad domino).

Solucion: Imaginemos n=8. Las soluciones parciales $a$, las puedo pensar como
cada valor como el valor de la fila i-esima (columna donde esta la reina en esa fila).
Con esto puedo pedir que no haya numeros repetidos, ya que seria reinas en misma columna y se
amenazarian.
Puedo pedir que cuando voy a agregar un nuevo valor $a_k$, que no este en la diagonal
de ningun valor anterior.
Ej: Sucesores(a,k) = $(a,a_k): \{a_k \in \{1,...,8\}, a_k-a_j \notin\{k-j,0,j-k\}\forall j\in\{1,...,k-1\}\}.$

\subsection{clase2}
\paragraph{Algos golosos}:
Construir una solucion seleccionando en cada paso la mejor alternativa posible localmente
(de ahi lo goloso, se come lo mejor en el momento sin importarle el futuro)
segun una funcion de seleccion, sin considerar (o haciendolo debilmente)
las implicancias de esta seleccion.
Son eficientes ya que una decision tomada nunca es revisada y no se evaluan alternativas.
A pesar de que son faciles de pensar e implementar no siempre funcionan.
Algunos problemas no pueden ser resueltos por este enfoque.

Proporcionan heuristicas (algoritmos que me dan soluciones validad pero no necesariamente
la mejor) sencillas para problemas de optimizacion.
En generar permiten construir soluciones razonables, pero suboptimas.
Tengo que elegir la funcion de seleccion en cada caso.

Un ejemplo seria el problema de la mochila (continuo, permito poner fracciones de objetos).
Quiero llenar una mochina con un limite de peso maximizando el beneficio.
Entonces el algoritmo es agrego objetos mientras no me exceda de peso.
Y utilizo una funcion de seleccion como mayor beneficio, o el de menor peso, o
el que tiene mayor benificio por unidad de peso (b/p).

\paragraph{Programacion dinamica}
Al igual que D$\&$C, el problema es dividido en subproblemas de tamaño menores que son mas faciles
de resolver.
Una vez resueltos estos subproblemas, se combinan las soluciones obtenidas para generar
la solucion del problema original.
Sirve para problemas de optimizacion combinatoria y tambien los de naturaleza recursiva.
Este tipo de algoritmos se usan cuando los problemas tienen la caracteristica de
resolver varias veces un subproblema.
Con divide and conquer se resolveria el mismo problema tantas veces como se llamen.
Aca evita repetir llamadas recursivas almacenando los resultados calculados.
La estructura donde guardamos los datos se llama esquema de memoizacion.
Puede tener una forma de seleccionar que resultados de subproblemas guardar.

Un ejemplo claro es para calcular el factorial.
Luego el esquema puede ser top-down o bottom-up.
Tomando el ejemplo del factorial, voy utilizando y veo si ya calcule un dado valor,
si no lo calculo y lo meto ahi (en general llego asi hasta el caso base y vuelvo
a subir en la recurscion).
Si no bottom-up, precalculo y agrego la informacion trivial.
Asi puedo ir calculando y llenando la tabla hasta llegar al valor que quiero.
Empiezo por las sub-instancias mas chicas y voy subiendo.

\paragraph{Heuristicos}:
 Son los algoritmos que intenta obtener solucion de buena calidad para el problema
 que se quiere resolver pero no necesariamente lo hace en todos los casos.
 No se puede asegurar que tan lejos esta la solucion encontrada con este metodo
 a la solucion optima.
 Si si puedo decir que tan lejos o cerca estoy se le dice algoritmo aproximado.

\end{document}
