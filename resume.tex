\documentclass[12pt, oneside]{article}
\usepackage{amsmath, amsthm, amssymb, calrsfs, wasysym, verbatim,  color, graphics, geometry}

\geometry{tmargin=.75in, bmargin=.75in, lmargin=.75in, rmargin = .75in}

\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Cdot}{\boldsymbol{\cdot}}

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{conv}{Convention}
\newtheorem{rem}{Remark}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}


\title{Resume: }
\author{Matias Mazzanti}
\date{}

\begin{document}

\maketitle
\tableofcontents

\vspace{.25in}

\section{ToDo}
\begin{itemize}
  \item Probabilidades (marginal, condicional, etc)
  \item CrossValidation vs Test
  \item Combinations and permutation
  \item Poisson distribution
  \item Random Walk
  \item Divergencia de KL
  \item Probabilistic generative model (generative?)
  \item Likelihood
  \item Metric (evidence)
  \item Multivariant Gaussian
  \item TrueSkill draw
\end{itemize}


\section{Algoritmo 3}
Algoritmo eficiente = orden polinomial
Algoritmo no eficiente = exponencial

Tecnicas de diseño de algoritmos
\begin{itemize}
  \item Fuerza bruta
  \item Backtracking
  \item Algoritmos golosos
  \item Recursividad
  \item Dividir y conquistar
  \item Programacion dinamica
  \item Heuristicas y algoritmos aproximados
\end{itemize}

\subsection{Clase1}
Ej: allar todas las formas posibles de colocar n reinas en un tablero de ajedrez de n x n casillas,
de forma que ninguna reina amenace a la otra.
\paragraph{Fuerza bruta}:
Analizar todas las posibilidades y quedarme con las que me interesan.

Solucion, genero TODAS las posibilidades y veo cuales cumplen.
Tengo n*n casillas y tengo que poner n reinas.
Tengo el combinatorio de (n$^2$ n) de posibilidades.

\paragraph{Backtracking}:
Tecnica para recorrer sistematicamente todas las posibles configuraciones del espacio de soluciones.
Las posibles configuraciones las llamamos soluciones validas.
Se parece a fuerza bruta pero aprovecha propiedades del problema para evitar analizar todas
las configuraciones posibles.
Se suele armar un vector de las soluciones candidatas.
Se puede pensar este espacio de busqueda como un arbol dirigido donde cada
vertice representa una solucion parcial.
Un vertice x es hijo de y si la solucion parcial de x se puede extender desde la
solucion parcial y.
La raiz del arbol se corresponde con el vector vacio.
Los vertices del primer nivel del arbol seran las soluciones parciales que ya tienen definidas
el primer elemento.
Los de segundo nivel las que tienen los dos primeros y asi siguierndo.
Si el vertice x corresponde a la solucion parcial a = $(a_1, a_2,...,a_k)$ por
cada valor posible que puede tomar $a_{k+1}$ se ramifica el arbol, generando
tantos hijos de x como posibilidades haya para $a_{k+1}$.
Las soluciones completas (cuando todos los$a_i$ tienen valor) corresponden a las
hojas del arbol.
Cuando podemos deducir que una solucion parcial no nos llevara a una solucion valida, no
es necesario seguir explorando esa rama del arbol de busqueda (se poda el arbol) y se
retrocede hasta encontrar un vertice con un hijo valido por donde seguir la exploracion.

Puedo podar tanto por factibilidad, que es cuando ninguna extension de la solucion parcial
derivara en una solucion valida del problema.
O bien por optimalidad, en que ninguna extension de la solucion parcial derivara en una solucion
del prblema optima.
En este ultimo caso puedo cortar la busqueda una vez que se que la solucion aparente que
puedo encontrar por una rama va a ser peor (en el sentido del problema) a alguna que ya encontre.
Para poder aplicar la poda por factibilidad, la representacion de las soluciones debe cumplir que
si una solucion parcial $a$ no cumple las propiedades deseadas, tampoco lo hara cualquier
extension posible de ella (propiedad domino).

Solucion: Imaginemos n=8. Las soluciones parciales $a$, las puedo pensar como
cada valor como el valor de la fila i-esima (columna donde esta la reina en esa fila).
Con esto puedo pedir que no haya numeros repetidos, ya que seria reinas en misma columna y se
amenazarian.
Puedo pedir que cuando voy a agregar un nuevo valor $a_k$, que no este en la diagonal
de ningun valor anterior.
Ej: Sucesores(a,k) = $(a,a_k): \{a_k \in \{1,...,8\}, a_k-a_j \notin\{k-j,0,j-k\}\forall j\in\{1,...,k-1\}\}.$

\subsection{clase2}
\paragraph{Algos golosos}:
Construir una solucion seleccionando en cada paso la mejor alternativa posible localmente
(de ahi lo goloso, se come lo mejor en el momento sin importarle el futuro)
segun una funcion de seleccion, sin considerar (o haciendolo debilmente)
las implicancias de esta seleccion.
Son eficientes ya que una decision tomada nunca es revisada y no se evaluan alternativas.
A pesar de que son faciles de pensar e implementar no siempre funcionan.
Algunos problemas no pueden ser resueltos por este enfoque.

Proporcionan heuristicas (algoritmos que me dan soluciones validad pero no necesariamente
la mejor) sencillas para problemas de optimizacion.
En generar permiten construir soluciones razonables, pero suboptimas.
Tengo que elegir la funcion de seleccion en cada caso.

Un ejemplo seria el problema de la mochila (continuo, permito poner fracciones de objetos).
Quiero llenar una mochina con un limite de peso maximizando el beneficio.
Entonces el algoritmo es agrego objetos mientras no me exceda de peso.
Y utilizo una funcion de seleccion como mayor beneficio, o el de menor peso, o
el que tiene mayor benificio por unidad de peso (b/p).

\paragraph{Programacion dinamica}
Al igual que D$\&$C, el problema es dividido en subproblemas de tamaño menores que son mas faciles
de resolver.
Una vez resueltos estos subproblemas, se combinan las soluciones obtenidas para generar
la solucion del problema original.
Sirve para problemas de optimizacion combinatoria y tambien los de naturaleza recursiva.
Este tipo de algoritmos se usan cuando los problemas tienen la caracteristica de
resolver varias veces un subproblema.
Con divide and conquer se resolveria el mismo problema tantas veces como se llamen.
Aca evita repetir llamadas recursivas almacenando los resultados calculados.
La estructura donde guardamos los datos se llama esquema de memoizacion.
Puede tener una forma de seleccionar que resultados de subproblemas guardar.

Un ejemplo claro es para calcular el factorial.
Luego el esquema puede ser top-down o bottom-up.
Tomando el ejemplo del factorial, voy utilizando y veo si ya calcule un dado valor,
si no lo calculo y lo meto ahi (en general llego asi hasta el caso base y vuelvo
a subir en la recurscion).
Si no bottom-up, precalculo y agrego la informacion trivial.
Asi puedo ir calculando y llenando la tabla hasta llegar al valor que quiero.
Empiezo por las sub-instancias mas chicas y voy subiendo.

\paragraph{Heuristicos}:
 Son los algoritmos que intenta obtener solucion de buena calidad para el problema
 que se quiere resolver pero no necesariamente lo hace en todos los casos.
 No se puede asegurar que tan lejos esta la solucion encontrada con este metodo
 a la solucion optima.
 Si si puedo decir que tan lejos o cerca estoy se le dice algoritmo aproximado.

\section{Clase 3: Grafos}
Un grafo G=(V,X) es un par de conjuntos, donde V es un conjunto de puntos o nodos o \textbf{vertices}
 y X es un  subconjunto del conjunto de pares no ordenados de elementos distintos de V.

Los elemetos de X se llaman \textbf{aristas} o ejes.
Dado v y w $\in$ V, si e=(v,w)$\in$X se dice que v y w son adyacentes y que e es incidente
a v y w.
En general denotamos como n a la cantidad de nodos $|V|$ y m a la cantidad de aristas
$|X|$.

Denominamos multigrafos a los grafos donde puede haber varias aristas entre el mismo
par de vertices distintos.
Denominamos pseudografo a los  grafos en el que puede haber varias aristas entre cada par de
vertices y tambien puede haber aristas (loops) que unan  a un vertice con si mismo.

El grado de un vertice v en el grafo G, $d_G(v)$ es la cantidad de aristas incidentes a v en G.
Llamamos $\triangle$(G) al maximo grado de los vertices de G y $\delta$(G) al minimo.

Teorema:
La suma de los grados de los vertices de un grafo es igual a 2 veces el numero de aristas.
\begin{equation}
  \sum_{i=1}^n d(v_i)=2m
\end{equation}

Corolario, la cantidad de vertices de un grafo de grado impar es par.
\subsection{Propiedades}

Denominamos como grafo \textbf{completo} si todos los vertices son adyacentes entre si.
Y denominamos a un grafo completo de G=(V,X) como $\bar{\text{G}}=(V,\bar{\text{X}})$,
al mismo conjunto de vertices y un par de vertices son adyacentes en $\bar{\text{G}}$ si y solo
si no son adyacentes en G.

Un \textbf{recorrido} en un grafo es una secuencia alternada de vertices y aritas tal que un extremo
de la arista $e_i$ es $v_{i-1}$ y el otro es $v_i$ para i = 1,...,k.
Decimos que P es un recorrido entre $v_0$ y $v_k$.
P = $v_0e_1v_1e_2...v_{k-1}e_kv_k$.
En los grafos (ni multi ni pseudo) un recorrido queda definido por la secuencia de vertices solamente.

Un \textbf{camino} es un recorrido que no pasa dos veces por el mismo vertice.
Una \textbf{seccion} de un camino P es una subsecuencia de terminos consecutivos de P y lo denotamos
como P$_{v_jv_i}$.
Un \textbf{circuito} es un recorrido que empieza y termina en el mismo vertice.
Un \textbf{ciclo} o circuito simple es un circuito de 3 o mas vertices que no pasa dos veces por el
mismo vertice.

Dado un recorrido P, su longitud I(P) es la cantidad de aristas que tiene.
La \textbf{distancia} entre dos vertices v y w, d(v,w), se define como la longitud del
recorrido mas corto entre v y w.
En caso de no existir recorrido se dice que la distancia es infinita.
La funcion distancia cumple la desigualdad triangular, es conmutativa y es mayor a cero.
Solo es cero en el caso que pida la distancia entre el mismo nodo.

Proposicion: Si un recorrido P entre v y w tiene longitud d(v,w), P debe ser un camino.

\subsection{Subgrafos}
Dado un grafo G=($V_G,X_G$), un \textbf{subgrafo} de G es un grafo H=($V_H,X_H$)
tal que $V_H \subseteq V_G$ y $X_H \subseteq X_G \cap(V_H\times V_H)$.
Es decir que no dejamos arista sin vertice.
Lo notamos como $H\subseteq G$.
\begin{itemize}
  \item Si  $H\subseteq G$ y $H\neq G$ entonces H es subgrafo propio de G,
     $H\subset G$.
   \item H es subgrafo generador de G si  $H\subseteq G$ y $V_G=V_H$.
   \item H = ($V_h, X_H)$ de G = ($V_G,X_G$), es un subgrafo inducido si todo
     par u, v $\in V_H$ con (u,v)$\in X_G$ entinces tambien (u,v)$\in X_H$.
\end{itemize}
Un subgrafo inducido de G=($V_G,X_G$) por un conjunto de vertices $V'\subseteq V_G$,
se denota como $G_{[V']}$.

Un grafo se dice \textbf{conexo}si existe camino entre todo par de vertices.
Una \textbf{componente conexa} de un grafo G es un subgrafo conexo maximal de G.

Un grafo G=(V,X) se dice \textbf{bipartito}si existen dos subconjuntos $V_1, V_2$ del
conjunto de vertices de V tal que:
\begin{equation}
  V=V_1 \cup V_2, \hspace{2cm} V_1 \cap V_2=\emptyset
\end{equation}
Y tal que todas las aristas de G tienen un extremo en $V_1$ y otro en $V_2$.
Es decir que puedo separar los nodos de un grafo en dos subconjuntos y
los nodos de cada subconjunto no tienen aristas entre si.
Solo tienen aristas con los nodos del otro subconjunto.

Un grafo bipartito con subconjutos $V_1, V_2$, es \textbf{bipartito completo} si todo
vertice en $V_1$ es adyacente a todo vertice en $V_2$.

Teorema: un grafo G es pipartito si y solo si no tiene ciclos de longitud impar.

\subsection{Isomorfismo}
Dados dos grafos G=(V,X) y $G'=(V',X')$ se dicen isomorfos si existe una funcion biyectiva
f$:V\rightarrow V'$ tal que para todo v,w$\in$V:
\begin{equation}
  (v,w)\in X \iff (f(v),f(w))\in X'
\end{equation}
La funcion $f$ es llamada funcion de isomorfismo.
Cuando G y $G'$ son isomorfos lo notaremos como $G\cong G'$ o con abuso de notacion $G=G'$.

Proposicion:
Si dos grafos G=(V,X) y $\text{G}'=(V',X')$ son isomorfos, entonces:
\begin{itemize}
  \item Tienen el mismo numero de vertices
  \item Tienen el mismo numero de aristas
  \item Para todo k, $0\leq k\leq n-1$, tienen el mismo numero de vertices de grado k
  \item Tienen el mismo numero de componentes conexas
  \item Para todo  k, $1\leq k\leq n-1$, tienen el mismo numero de caminos de
    longitud k
\end{itemize}
No vale la reciproca.
Es decir dado dos grafos que cumplen todas estas propiedades pueden igual no ser
isomorfos.
Son condiciones necesarias no suficientes.

\subsection{representacion}
Se pueden representar grafos mediante matrices.
No es muy eficiente a nivel memoria, pero es muy conceptual.
Tambien se puede representar con Listas que es mas eficiente en espacio.

Matriz de adyacencia.
$A\in \{0,1\}^{n\times n}$ donde los elementos $a_{ij}$ de A se definen como:
\begin{equation}
  a_{ij}= \left\{ \begin{array}{lcc}
    1 &   si  & G \text{ tiene una arista entre los vertices } v_i \text{ y } v_j \\
             \\ 0 &  si  & no
             \end{array}
   \right.
\end{equation}

Proposicion:
Si A es la matriz de adyacencia del grafo G, entonces:
\begin{itemize}
  \item La suma de los elementos de la columna $i$ de A (o fila $i$, dado
    que A es simetrica) es igual a $d(v_i)$.
  \item Los elementos de la diagonal  de $A^2$ indican los grados de los
    vertices: $a_{ij}^2=d(v_i)$
\end{itemize}

\subsection{Digrafos}

Un \textbf{digrafo}G= (V,X) es un par de conjuntos V y X donde V es el conjunto
de puntos, nodos o vertices y X es un subconjunto del conjunto de los pares \textbf{ordenados} de
elementos distintos de V.
A los elementos de X los llamaremos \textbf{arcos}.

Dado un arco e=(u,w) llamaremos al primer elemento u \textbf{cola} de e  y al segundo
elemento w, \textbf{cabeza} de e.

El \textbf{grado de entrada} $d_{in}(v)$ de un vertice v de un digrafo es la
cantidad de arcos que llegan a v.
Es decir, la cantidad de arcos que tienen a v como cabeza.

El \textbf{grado de salida} $d_{out}(v)$ de un vertice v de un digrafo es la cantidad de arcos
que salen de v.
Es decir, la cantidad de arcos que tienen a v como cola.

El \textbf{grafo subyacente} de un digrafo es el grafo $G^s$ que resulta de
remover las direcciones de sus arcos (si para un par de vertices hay arcos en ambas
direcciones, solo se coloca una arista entre ellos).

Matriz de adyacencia de unn digrafo G.
$A\in \{0,1\}^{n\times n}$ donde los elementos $a_{ij}$ de A se definen como:
\begin{equation}
  a_{ij}= \left\{ \begin{array}{lcc}
    1 &   si  & G \text{ tiene un arc de } v_i \text{ a } v_j \\
             \\ 0 &  si  & no
             \end{array}
   \right.
\end{equation}
En general deja de ser simetrica.

Proposicion:
Si A es la matriz de adyacencia del digrafo G, entonces:
\begin{itemize}
  \item La suma de los elementos de la fila $i$ de A es igual a $d_{out}(v_i)$.
  \item Los elementos de la columna $i$  de A es igual a $d_{in}(v_i)$
\end{itemize}

Las definiciones de recorrido, camino, circutio o ciclo son analogas pero ahora son orientadas ya que
hay que respetar el sentido.

Un digrafo se dice \textbf{fuertemente conexo} si para todo par de vertices u, v existe un
camino orientado de u a v.

\end{document}
