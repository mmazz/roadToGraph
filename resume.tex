\documentclass[12pt, oneside]{article}
\usepackage{amsmath, amsthm, amssymb, calrsfs, wasysym, verbatim,  color, graphics, geometry}

\geometry{tmargin=.75in, bmargin=.75in, lmargin=.75in, rmargin = .75in}

\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Cdot}{\boldsymbol{\cdot}}

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{conv}{Convention}
\newtheorem{rem}{Remark}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}


\title{Resume: }
\author{Matias Mazzanti}
\date{}

\begin{document}

\maketitle
\tableofcontents

\vspace{.25in}

\section{ToDo}
\begin{itemize}
  \item Probabilidades (marginal, condicional, etc)
  \item CrossValidation vs Test
  \item Combinations and permutation
  \item Poisson distribution
  \item Random Walk
  \item Divergencia de KL
  \item Probabilistic generative model (generative?)
  \item Likelihood
  \item Metric (evidence)
  \item Multivariant Gaussian
  \item TrueSkill draw
\end{itemize}


\section{Algoritmo 3}
Algoritmo eficiente = orden polinomial
Algoritmo no eficiente = exponencial

Tecnicas de diseño de algoritmos
\begin{itemize}
  \item Fuerza bruta
  \item Backtracking
  \item Algoritmos golosos
  \item Recursividad
  \item Dividir y conquistar
  \item Programacion dinamica
  \item Heuristicas y algoritmos aproximados
\end{itemize}

\subsection{Clase1}
Ej: allar todas las formas posibles de colocar n reinas en un tablero de ajedrez de n x n casillas,
de forma que ninguna reina amenace a la otra.
\paragraph{Fuerza bruta}:
Analizar todas las posibilidades y quedarme con las que me interesan.

Solucion, genero TODAS las posibilidades y veo cuales cumplen.
Tengo n*n casillas y tengo que poner n reinas.
Tengo el combinatorio de (n$^2$ n) de posibilidades.

\paragraph{Backtracking}:
Tecnica para recorrer sistematicamente todas las posibles configuraciones del espacio de soluciones.
Las posibles configuraciones las llamamos soluciones validas.
Se parece a fuerza bruta pero aprovecha propiedades del problema para evitar analizar todas
las configuraciones posibles.
Se suele armar un vector de las soluciones candidatas.
Se puede pensar este espacio de busqueda como un arbol dirigido donde cada
vertice representa una solucion parcial.
Un vertice x es hijo de y si la solucion parcial de x se puede extender desde la
solucion parcial y.
La raiz del arbol se corresponde con el vector vacio.
Los vertices del primer nivel del arbol seran las soluciones parciales que ya tienen definidas
el primer elemento.
Los de segundo nivel las que tienen los dos primeros y asi siguierndo.
Si el vertice x corresponde a la solucion parcial a = $(a_1, a_2,...,a_k)$ por
cada valor posible que puede tomar $a_{k+1}$ se ramifica el arbol, generando
tantos hijos de x como posibilidades haya para $a_{k+1}$.
Las soluciones completas (cuando todos los$a_i$ tienen valor) corresponden a las
hojas del arbol.
Cuando podemos deducir que una solucion parcial no nos llevara a una solucion valida, no
es necesario seguir explorando esa rama del arbol de busqueda (se poda el arbol) y se
retrocede hasta encontrar un vertice con un hijo valido por donde seguir la exploracion.

Puedo podar tanto por factibilidad, que es cuando ninguna extension de la solucion parcial
derivara en una solucion valida del problema.
O bien por optimalidad, en que ninguna extension de la solucion parcial derivara en una solucion
del prblema optima.
En este ultimo caso puedo cortar la busqueda una vez que se que la solucion aparente que
puedo encontrar por una rama va a ser peor (en el sentido del problema) a alguna que ya encontre.
Para poder aplicar la poda por factibilidad, la representacion de las soluciones debe cumplir que
si una solucion parcial $a$ no cumple las propiedades deseadas, tampoco lo hara cualquier
extension posible de ella (propiedad domino).

Solucion: Imaginemos n=8. Las soluciones parciales $a$, las puedo pensar como
cada valor como el valor de la fila i-esima (columna donde esta la reina en esa fila).
Con esto puedo pedir que no haya numeros repetidos, ya que seria reinas en misma columna y se
amenazarian.
Puedo pedir que cuando voy a agregar un nuevo valor $a_k$, que no este en la diagonal
de ningun valor anterior.
Ej: Sucesores(a,k) = $(a,a_k): \{a_k \in \{1,...,8\}, a_k-a_j \notin\{k-j,0,j-k\}\forall j\in\{1,...,k-1\}\}.$

\subsection{clase2}
\paragraph{Algos golosos}:
Construir una solucion seleccionando en cada paso la mejor alternativa posible localmente
(de ahi lo goloso, se come lo mejor en el momento sin importarle el futuro)
segun una funcion de seleccion, sin considerar (o haciendolo debilmente)
las implicancias de esta seleccion.
Son eficientes ya que una decision tomada nunca es revisada y no se evaluan alternativas.
A pesar de que son faciles de pensar e implementar no siempre funcionan.
Algunos problemas no pueden ser resueltos por este enfoque.

Proporcionan heuristicas (algoritmos que me dan soluciones validad pero no necesariamente
la mejor) sencillas para problemas de optimizacion.
En generar permiten construir soluciones razonables, pero suboptimas.
Tengo que elegir la funcion de seleccion en cada caso.

Un ejemplo seria el problema de la mochila (continuo, permito poner fracciones de objetos).
Quiero llenar una mochina con un limite de peso maximizando el beneficio.
Entonces el algoritmo es agrego objetos mientras no me exceda de peso.
Y utilizo una funcion de seleccion como mayor beneficio, o el de menor peso, o
el que tiene mayor benificio por unidad de peso (b/p).

\paragraph{Programacion dinamica}
Al igual que D$\&$C, el problema es dividido en subproblemas de tamaño menores que son mas faciles
de resolver.
Una vez resueltos estos subproblemas, se combinan las soluciones obtenidas para generar
la solucion del problema original.
Sirve para problemas de optimizacion combinatoria y tambien los de naturaleza recursiva.
Este tipo de algoritmos se usan cuando los problemas tienen la caracteristica de
resolver varias veces un subproblema.
Con divide and conquer se resolveria el mismo problema tantas veces como se llamen.
Aca evita repetir llamadas recursivas almacenando los resultados calculados.
La estructura donde guardamos los datos se llama esquema de memoizacion.
Puede tener una forma de seleccionar que resultados de subproblemas guardar.

Un ejemplo claro es para calcular el factorial.
Luego el esquema puede ser top-down o bottom-up.
Tomando el ejemplo del factorial, voy utilizando y veo si ya calcule un dado valor,
si no lo calculo y lo meto ahi (en general llego asi hasta el caso base y vuelvo
a subir en la recurscion).
Si no bottom-up, precalculo y agrego la informacion trivial.
Asi puedo ir calculando y llenando la tabla hasta llegar al valor que quiero.
Empiezo por las sub-instancias mas chicas y voy subiendo.

\paragraph{Heuristicos}:
 Son los algoritmos que intenta obtener solucion de buena calidad para el problema
 que se quiere resolver pero no necesariamente lo hace en todos los casos.
 No se puede asegurar que tan lejos esta la solucion encontrada con este metodo
 a la solucion optima.
 Si si puedo decir que tan lejos o cerca estoy se le dice algoritmo aproximado.

\section{Clase 3: Grafos}
Un grafo G=(V,X) es un par de conjuntos, donde V es un conjunto de puntos o nodos o \textbf{vertices}
 y X es un  subconjunto del conjunto de pares no ordenados de elementos distintos de V.

Los elemetos de X se llaman \textbf{aristas} o ejes.
Dado v y w $\in$ V, si e=(v,w)$\in$X se dice que v y w son adyacentes y que e es incidente
a v y w.
En general denotamos como n a la cantidad de nodos $|V|$ y m a la cantidad de aristas
$|X|$.

Denominamos multigrafos a los grafos donde puede haber varias aristas entre el mismo
par de vertices distintos.
Denominamos pseudografo a los  grafos en el que puede haber varias aristas entre cada par de
vertices y tambien puede haber aristas (loops) que unan  a un vertice con si mismo.

El grado de un vertice v en el grafo G, $d_G(v)$ es la cantidad de aristas incidentes a v en G.
Llamamos $\triangle$(G) al maximo grado de los vertices de G y $\delta$(G) al minimo.

Teorema:
La suma de los grados de los vertices de un grafo es igual a 2 veces el numero de aristas.
\begin{equation}
  \sum_{i=1}^n d(v_i)=2m
\end{equation}

Corolario, la cantidad de vertices de un grafo de grado impar es par.
\subsection{Propiedades}

Denominamos como grafo \textbf{completo} si todos los vertices son adyacentes entre si.
Y denominamos a un grafo completo de G=(V,X) como $\bar{\text{G}}=(V,\bar{\text{X}})$,
al mismo conjunto de vertices y un par de vertices son adyacentes en $\bar{\text{G}}$ si y solo
si no son adyacentes en G.

Un \textbf{recorrido} en un grafo es una secuencia alternada de vertices y aritas tal que un extremo
de la arista $e_i$ es $v_{i-1}$ y el otro es $v_i$ para i = 1,...,k.
Decimos que P es un recorrido entre $v_0$ y $v_k$.
P = $v_0e_1v_1e_2...v_{k-1}e_kv_k$.
En los grafos (ni multi ni pseudo) un recorrido queda definido por la secuencia de vertices solamente.

Un \textbf{camino} es un recorrido que no pasa dos veces por el mismo vertice.
Una \textbf{seccion} de un camino P es una subsecuencia de terminos consecutivos de P y lo denotamos
como P$_{v_jv_i}$.
Un \textbf{circuito} es un recorrido que empieza y termina en el mismo vertice.
Un \textbf{ciclo} o circuito simple es un circuito de 3 o mas vertices que no pasa dos veces por el
mismo vertice.

Dado un recorrido P, su longitud I(P) es la cantidad de aristas que tiene.
La \textbf{distancia} entre dos vertices v y w, d(v,w), se define como la longitud del
recorrido mas corto entre v y w.
En caso de no existir recorrido se dice que la distancia es infinita.
La funcion distancia cumple la desigualdad triangular, es conmutativa y es mayor a cero.
Solo es cero en el caso que pida la distancia entre el mismo nodo.

Proposicion: Si un recorrido P entre v y w tiene longitud d(v,w), P debe ser un camino.

\subsection{Subgrafos}
Dado un grafo G=($V_G,X_G$), un \textbf{subgrafo} de G es un grafo H=($V_H,X_H$)
tal que $V_H \subseteq V_G$ y $X_H \subseteq X_G \cap(V_H\times V_H)$.
Es decir que no dejamos arista sin vertice.
Lo notamos como $H\subseteq G$.
\begin{itemize}
  \item Si  $H\subseteq G$ y $H\neq G$ entonces H es subgrafo propio de G,
     $H\subset G$.
   \item H es subgrafo generador de G si  $H\subseteq G$ y $V_G=V_H$.
   \item H = ($V_h, X_H)$ de G = ($V_G,X_G$), es un subgrafo inducido si todo
     par u, v $\in V_H$ con (u,v)$\in X_G$ entinces tambien (u,v)$\in X_H$.
\end{itemize}
Un subgrafo inducido de G=($V_G,X_G$) por un conjunto de vertices $V'\subseteq V_G$,
se denota como $G_{[V']}$.

Un grafo se dice \textbf{conexo}si existe camino entre todo par de vertices.
Una \textbf{componente conexa} de un grafo G es un subgrafo conexo maximal de G.

Un grafo G=(V,X) se dice \textbf{bipartito}si existen dos subconjuntos $V_1, V_2$ del
conjunto de vertices de V tal que:
\begin{equation}
  V=V_1 \cup V_2, \hspace{2cm} V_1 \cap V_2=\emptyset
\end{equation}
Y tal que todas las aristas de G tienen un extremo en $V_1$ y otro en $V_2$.
Es decir que puedo separar los nodos de un grafo en dos subconjuntos y
los nodos de cada subconjunto no tienen aristas entre si.
Solo tienen aristas con los nodos del otro subconjunto.

Un grafo bipartito con subconjutos $V_1, V_2$, es \textbf{bipartito completo} si todo
vertice en $V_1$ es adyacente a todo vertice en $V_2$.

Teorema: un grafo G es pipartito si y solo si no tiene ciclos de longitud impar.

\subsection{Isomorfismo}
Dados dos grafos G=(V,X) y $G'=(V',X')$ se dicen isomorfos si existe una funcion biyectiva
f$:V\rightarrow V'$ tal que para todo v,w$\in$V:
\begin{equation}
  (v,w)\in X \iff (f(v),f(w))\in X'
\end{equation}
La funcion $f$ es llamada funcion de isomorfismo.
Cuando G y $G'$ son isomorfos lo notaremos como $G\cong G'$ o con abuso de notacion $G=G'$.

Proposicion:
Si dos grafos G=(V,X) y $\text{G}'=(V',X')$ son isomorfos, entonces:
\begin{itemize}
  \item Tienen el mismo numero de vertices
  \item Tienen el mismo numero de aristas
  \item Para todo k, $0\leq k\leq n-1$, tienen el mismo numero de vertices de grado k
  \item Tienen el mismo numero de componentes conexas
  \item Para todo  k, $1\leq k\leq n-1$, tienen el mismo numero de caminos de
    longitud k
\end{itemize}
No vale la reciproca.
Es decir dado dos grafos que cumplen todas estas propiedades pueden igual no ser
isomorfos.
Son condiciones necesarias no suficientes.

\subsection{representacion}
Se pueden representar grafos mediante matrices.
No es muy eficiente a nivel memoria, pero es muy conceptual.
Tambien se puede representar con Listas que es mas eficiente en espacio.

\paragraph{Matriz de adyacencia}.
$A\in \{0,1\}^{n\times n}$ donde los elementos $a_{ij}$ de A se definen como:
\begin{equation}
  a_{ij}= \left\{ \begin{array}{lcc}
    1 &   si  & G \text{ tiene una arista entre los vertices } v_i \text{ y } v_j \\
             \\ 0 &  si  & no
             \end{array}
   \right.
\end{equation}

Proposicion:
Si A es la matriz de adyacencia del grafo G, entonces:
\begin{itemize}
  \item La suma de los elementos de la columna $i$ de A (o fila $i$, dado
    que A es simetrica) es igual a $d(v_i)$.
  \item Los elementos de la diagonal  de $A^2$ indican los grados de los
    vertices: $a_{ij}^2=d(v_i)$
\end{itemize}


Las ventajas que tiene es que permite saber si existe o no arista entre dos nodos cualquiera
en O(1).
Ademas es muy facil de implementar.
Las desventajas es la complejidad espacial, se necesitan $n^2$ casillas para representar un
grafo de n nodos.
Recorrer los vecinos de un nodo siempre tarda O(n).

\paragraph{Lista de adyacencia}:
Es la lista de vecinos, pues para cada nodo guardamos la lista de nodos para los que existe
una arista que los conecta.
Tengo una lista por cada nodo.
Si la lista de vecinos esta ordenada, para consultar si dos nodos tienen una arista que los une es
O(log n).

Las ventajas es que la complejidad espacial para un grafo de n nodos y m aristas es O(n+m) osea lineal.
Ademas recorrer los vecinos de un nodo es o(v) donde v es la cantidad de vecinos.

Las desventajas es que ahora chequear si dos nodos son adyacentes ya no es O(1).
Ademas es mas dificil de implementar.

\paragraph{Lista de incidencia}:
Se define como la cantidad de nodos de G y una lista con las aristas de G representadas por
los dos vertices que conecta (tipo tupla).

Las ventajas son que la complejidad espacial lineal en la cantidad de ariastas.
Es facil de implementar y puedo ordenar las aristas con algun criterio.

Las desventajas chequear si dos nodos son adyacentes no es O(1) y recorrer los vecinos
tambien empeora.


\subsection{Digrafos}

Un \textbf{digrafo}G= (V,X) es un par de conjuntos V y X donde V es el conjunto
de puntos, nodos o vertices y X es un subconjunto del conjunto de los pares \textbf{ordenados} de
elementos distintos de V.
A los elementos de X los llamaremos \textbf{arcos}.

Dado un arco e=(u,w) llamaremos al primer elemento u \textbf{cola} de e  y al segundo
elemento w, \textbf{cabeza} de e.

El \textbf{grado de entrada} $d_{in}(v)$ de un vertice v de un digrafo es la
cantidad de arcos que llegan a v.
Es decir, la cantidad de arcos que tienen a v como cabeza.

El \textbf{grado de salida} $d_{out}(v)$ de un vertice v de un digrafo es la cantidad de arcos
que salen de v.
Es decir, la cantidad de arcos que tienen a v como cola.

El \textbf{grafo subyacente} de un digrafo es el grafo $G^s$ que resulta de
remover las direcciones de sus arcos (si para un par de vertices hay arcos en ambas
direcciones, solo se coloca una arista entre ellos).

Matriz de adyacencia de unn digrafo G.
$A\in \{0,1\}^{n\times n}$ donde los elementos $a_{ij}$ de A se definen como:
\begin{equation}
  a_{ij}= \left\{ \begin{array}{lcc}
    1 &   si  & G \text{ tiene un arc de } v_i \text{ a } v_j \\
             \\ 0 &  si  & no
             \end{array}
   \right.
\end{equation}
En general deja de ser simetrica.

Proposicion:
Si A es la matriz de adyacencia del digrafo G, entonces:
\begin{itemize}
  \item La suma de los elementos de la fila $i$ de A es igual a $d_{out}(v_i)$.
  \item Los elementos de la columna $i$  de A es igual a $d_{in}(v_i)$
\end{itemize}

Las definiciones de recorrido, camino, circutio o ciclo son analogas pero ahora son orientadas ya que
hay que respetar el sentido.

Un digrafo se dice \textbf{fuertemente conexo} si para todo par de vertices u, v existe un
camino orientado de u a v.

\section{Clase 4: arboles}
Un arbol es un grafo conexo sin circuitos simples y minimamente conexos, si le saco cualquier
arista dejan de ser conexo.
Un \textbf{puente} es una arista de un grafo G que si G-e tiene mas componentes conextas que G.

Una hoja es un nodo de grado 1.
Todo arbol no trivial tiene al menos dos hojas.
Y la cantidad de ariastas (m) de un arbol es igual a la cantidad de nodos (n) - 1.

Un \textbf{bosque} es un grafo sin circuitos simples.
Dado G un bosque con c componentes conexas entonces m=n-c.

Dado un G cualquiera con c componentes conexas vale que m$\geq$n-c.

Un \textbf{arbol enraizado} es un arbol que tiene un vertice distinguido que llamamos \textbf{raiz}.
Explicitamente queda definido un arbol dirigido.
El nivel de un vertice es la distancia de la raiz a ese vertice.
La \textbf{altura} h de un arbol enraizado es el maximo nivel de sus vertices.

Un arbol se dice (exactamente) m-ario si todos sus vertices, salvo las hojas y la raiz
tienen grado (exactamente) a lo sumo m+1 y la raiz (exactamente) a lo sumo m.
Un arbol se dice \textbf{balanceado} si todas sus hojas estan a nivel h o h-1.
Un arbol se dice \textbf{balanceado completo} si todas sus hojas estan a nivel h.

Los vertices \textbf{internos} de un arbol son aquellos que no son ni hojas ni la raiz.
Decimos que dos vertices adyacentes tienen relacion padre-hijo, siendo el padre el
vertice de menor nivel.

Un arbol m-ario de altura h tiene a lo sumo $m^h$ hojas.
Ademas si tiene L hojas tiene h$\geq log_mL$.
En caso de ser exactamente m-ario balanceado completo es el igual.

Un \textbf{arbol generador} (AG) de un grafo G es un subgrafo generador (que tiene el msimo
conjunto de vertices) de G que es arbol.
Recordemos que es subgrafo si tiene todas las aristas del subgrafo son aristas de G, mismo
conjunto de vertices.

Todo grafo conexo tienen al menos un arbol generador.

Forma ordenada y sistematica de recorrer los vertices de un arbol o grafo exactamente
una vez:
En caso de un grafo, arranco por cualquier nodo denominandolo raiz.
\begin{itemize}
\item a lo ancho (Breadth-First Search - BFS): se comienza por el nivel 0 (raiz)
  y se visita cada vertice en un nivel antes de pasar al siguiente nivel.
  Se implementa una lista como cola.
\item en profundidad (Depth-First Search - DFS: se comienza por la raiz y se explora cada
  rama lo mas profundo posible antes de retroceder.
  Se implementa una lista como pila.
\end{itemize}

\subsection{Arbol generador minimo}
Queremos conectar n puntos, pero cada conexion (arista) tiene un costo asociado y queremos minimizarlo.
Es optimizacion combinatoria.

Algoritmo de Prim (algoritmo golozo):
\begin{itemize}
  \item Contruye incrementalmente dos conjuntos.
  \begin{itemize}
    \item uno de vertices $V_T$, inicializado con un vertice cualquiera.
    \item uno de aristas $X_T$, que comienza vacio.
  \end{itemize}
  \item En cada iteracion se agrega un elemento a cada conjunto.
  \item En cada paso, se selecciona la arista de menor costo entre las que tienen un extremo
    en $V_T$ y el otro en $V \ V_T$.
  \item Esta arista es agregada a $X_T$ y el extremo a $V_T$.
  \item Cuando $V_T=V$ el algoritmo termina y las aristas de $X_T$ definen un AGM de G.
  \item Esta es una eleccion golosa: de un conjunto de aristas candidatas, elige la
    mejor arista (menor costo).
\end{itemize}

Algoritmo de Kruskal:
\begin{itemize}
  \item Ordena las aristas del grafo de forma creciente segun su peso.
  \item En cada paso elige la siguiente arista que no forme circuito con las aristas ya elegidas.
  \item El algoritmo para cuando selecciona n-1 aristas.
  \item Tambien es un algoritmo goloso.
\end{itemize}




\section{5 clase: Algoritmos para determinar caminos minimos}
Ejemplo clasico, camino minimo de un mapa de un punto a otro.

Representamos el mapa con un grafo donde:
\begin{itemize}
  \item Los vertices representan las intersecciones de las calles.
  \item Las aristas (o arcos si es orientado) los segmentos de calles entre dos intersecciones adyacentes.
  \item La funcion de peso corresponde a la longitud de este segmento.
\end{itemize}

Estos pesos pueden ser cualquier metrica.
Desde la distancia,  tiempo que se tarda en recorrerla, o cualquier
cantidad que se acumule linealmente a lo largo de un camino y querramos minimizar.

Sea G=(V,X) un grafo y l:$X\rightarrow R$ una funcion de longitud/peso para las aristas de G.

La longitud de un camino C entre dos cerices v y u es la suma de las longitudes de las
aristas del camino:
\begin{equation}
  l(C) = \sum_{e\in C} l(e)
\end{equation}

Un camino minimo $C^0$ entre v y u es un camino entre v y u tal que l$(C^0)$=min$\{l(C)|C \text{
  es un camino entre v y u}\}$

Existen varias variatnes:
\begin{itemize}
  \item Unico origen - unico destino: Determinar un camino minimo entre dos vertices especificos, v y u.
    (no vamos a ver algoritmos de esto, si no que veremos de unico origen - multiples destinos que son casos generales
    de este).
  \item Unico origen - multiples destinos: Determinar un camino minimo desde un vertice especifico v al resto
    de los vertices de G.
  \item Multiples origenes - multiples destinos: Determinar un camino minimo entre todo par de vertices de G.
\end{itemize}

\paragraph{Propiedad de subestrcutura optima de un camino minimo:}
 Dado un digrafo G=(V,X) con una funcion de peso l:$X\rightarrow R$, sea  P: $v_1,...,v_k$ un camino
 minimo de $v_1$ a $v_k$.
 Entonces $\forall 1\geq i \geq j \geq k, P_{v_iv_j}$ es un camino minimo desde $v_i$ a $v_j$.
 Recordar el principio de optimimalidad de Bellman.

 13:24
\end{document}
